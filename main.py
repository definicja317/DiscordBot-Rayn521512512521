import discord
from discord import app_commands, ui
from discord.ext import tasks
import os
import sys
import threading
from flask import Flask
from dotenv import load_dotenv
from datetime import datetime, timedelta, timezone # POPRAWKA: Upewnienie siƒô, ≈ºe timedelta i timezone sƒÖ zaimportowane
import re 
import traceback 
import time 

# --- Flask ---
app = Flask(__name__)

@app.route("/")
def home():
    return "Bot dzia≈Ça!"

# --- Token ---
load_dotenv()
token = os.getenv("DISCORD_BOT_TOKEN") 
if not token:
    print("B≈ÇƒÖd: brak tokena Discord. Ustaw DISCORD_BOT_TOKEN w Render lub w .env")
    sys.exit(1)

# --- Ustawienia ---
# WA≈ªNE: Wprowad≈∫ swoje faktyczne ID r√≥l/u≈ºytkownik√≥w.
# ZASTƒÑP SWOIMI ID
PICK_ROLE_ID = 1413424476770664499 
STATUS_ADMINS = [1184620388425138183, 1409225386998501480, 1007732573063098378, 364869132526551050] 
ADMIN_ROLES = STATUS_ADMINS 
BOT_ADMIN_ROLE_ID = 1413424476770664499 # U≈ºyte to samo ID, co PICK_ROLE_ID, do weryfikacji roli
ZANCUDO_IMAGE_URL = "https://cdn.discordapp.com/attachments/1224129510535069766/1414194392214011974/image.png"
CAYO_IMAGE_URL = "https://cdn.discordapp.com/attachments/1224129510535069766/1414204332747915274/image.png"
LOGO_URL = "https://cdn.discordapp.com/attachments/1184622314302754857/1420796249484824757/RInmPqb.webp?ex=68d6b31e&is=68d5619e&hm=0cdf3f7cbb269b12c9f47d7eb034e40a8d830ff502ca9ceacb3d7902d3819413&"

# --- Definicja strefy czasowej PL (UTC+2) ---
POLAND_TZ = timezone(timedelta(hours=2))

# --- POPRAWIONA FUNKCJA TIMERA ---
def create_timestamp(czas_str: str, data_str: str = None) -> int:
    """Konwertuje HH:MM i opcjonalnƒÖ datƒô DD.MM.RRRR lub DD.MM na Unix Timestamp (UTC)."""
    
    match = re.match(r"(\d{1,2}):(\d{2})", czas_str)
    if not match:
        raise ValueError("Nieprawid≈Çowy format czasu. U≈ºyj HH:MM (np. 21:30).")
    hour, minute = map(int, match.groups())

    now_pl = discord.utils.utcnow().astimezone(POLAND_TZ)
    dt_local = now_pl.replace(hour=hour, minute=minute, second=0, microsecond=0)
    
    if data_str:
        try:
            dt_base_naive = datetime.strptime(data_str, "%d.%m.%Y")
        except ValueError:
            try:
                dt_base_naive = datetime.strptime(data_str, "%d.%m").replace(year=now_pl.year)
            except ValueError:
                raise ValueError("Nieprawid≈Çowy format daty. U≈ºyj DD.MM.RRRR lub DD.MM (np. 27.09.2025).")
        
        final_dt = dt_local.replace(
            year=dt_base_naive.year, 
            month=dt_base_naive.month, 
            day=dt_base_naive.day,
            tzinfo=POLAND_TZ 
        )
    else:
        final_dt = dt_local 

    if final_dt < now_pl and not data_str:
        final_dt += timedelta(days=1)
    
    final_dt_utc = final_dt.astimezone(timezone.utc) 
    return int(final_dt_utc.timestamp())
# --- KONIEC FUNKCJI TIMERA ---


# --- Discord Client ---
intents = discord.Intents.default()
intents.members = True
client = discord.Client(intents=intents)
tree = app_commands.CommandTree(client)


# --- Globalna obs≈Çuga b≈Çƒôd√≥w ---
@tree.error
async def on_app_command_error(interaction: discord.Interaction, error: app_commands.AppCommandError):
    print(f"Globalny b≈ÇƒÖd komendy {interaction.command.name} (u≈ºytkownik: {interaction.user.display_name}):")
    traceback.print_exc() 
    
    # Obs≈Çuga b≈Çƒôdu 10062 (Wygas≈Ça interakcja)
    if isinstance(error, app_commands.CommandInvokeError) and isinstance(error.original, discord.NotFound) and "10062" in str(error.original):
        print("Wykryto i pominiƒôto b≈ÇƒÖd 10062 (Unknown interaction/Wygas≈Ça interakcja).")
        return
        
    # Obs≈Çuga b≈Çƒôd√≥w formatu daty/czasu (ValueError)
    if isinstance(error, app_commands.CommandInvokeError) and isinstance(error.original, ValueError):
        response_content = f"‚ùå B≈ÇƒÖd formatu czasu/daty: **{error.original}**"
    else:
        # Obs≈Çuga innych b≈Çƒôd√≥w
        error_name = type(error).__name__
        response_content = f"‚ùå WystƒÖpi≈Ç b≈ÇƒÖd w kodzie: `{error_name}`. Sprawd≈∫ logi bota! (Original: `{type(getattr(error, 'original', None)).__name__}`)"
            
    try:
        if interaction.response.is_done():
            await interaction.followup.send(response_content, ephemeral=True)
        else:
            await interaction.response.send_message(response_content, ephemeral=True)
            
    except discord.HTTPException:
        print("Nie uda≈Ço siƒô wys≈Çaƒá wiadomo≈õci o b≈Çƒôdzie do u≈ºytkownika, interakcja wygas≈Ça (10062).")
# --- KONIEC GLOBALNEJ OBS≈ÅUGI B≈ÅƒòD√ìW ---


# --- Pamiƒôƒá zapis√≥w ---
# WA≈ªNE: W przypadku restartu bota te dane zostanƒÖ wyczyszczone!
captures = {}   
airdrops = {}   
events = {"zancudo": {}, "cayo": {}} 
squads = {}     

# <<< ZARZƒÑDZANIE ZAPISAMI >>>
def get_all_active_enrollments():
    all_enrollments = []
    for msg_id, data in captures.items():
        all_enrollments.append(("Captures", msg_id, data))
    for msg_id, data in airdrops.items():
        all_enrollments.append(("AirDrop", msg_id, data))
    for etype, msgs in events.items():
        for msg_id, data in msgs.items():
            all_enrollments.append((etype.capitalize(), msg_id, data))
    return all_enrollments

class EnrollmentSelectMenu(ui.Select):
    def __init__(self, action: str):
        self.action = action 
        enrollments = get_all_active_enrollments()
        options = []
        for name, msg_id, data in enrollments:
            count = len(data.get("participants", []))
            options.append(
                discord.SelectOption(
                    label=f"{name} (ID: {msg_id}) - {count} os.", 
                    value=f"{name.lower()}-{msg_id}"
                )
            )
        super().__init__(
            placeholder=f"Wybierz zapis:",
            max_values=1,
            min_values=1,
            options=options,
        )
        self.custom_id = f"enrollment_select_{action}" 
        
    async def callback(self, interaction: discord.Interaction):
        # Ta funkcja nie musi nic robiƒá, poniewa≈º wyb√≥r jest obs≈Çugiwany przez guzik "Potwierd≈∫"
        pass 
# <<< KONIEC ZARZƒÑDZANIE ZAPISAMI >>>

# =====================
#       AIRDROP & CAPTURES VIEWS
# =====================
class AirdropView(ui.View):
    def __init__(self, message_id: int, description: str, voice_channel: discord.VoiceChannel, author_name: str, timestamp: int = None):
        super().__init__(timeout=None) 
        self.message_id = message_id
        self.description = description
        self.voice_channel = voice_channel
        self.participants: list[int] = [] 
        self.author_name = author_name
        self.timestamp = timestamp 
        self.custom_id = f"airdrop_view:{message_id}" 

    def make_embed(self, guild: discord.Guild):
        embed = discord.Embed(title="üéÅ AirDrop!", description=self.description, color=discord.Color(0xFFFFFF))
        embed.set_thumbnail(url=LOGO_URL)
        embed.add_field(name="Kana≈Ç g≈Çosowy:", value=f"üîä {self.voice_channel.mention}", inline=False)
        
        if self.timestamp:
            time_str = f"Rozpoczƒôcie AirDrop o <t:{self.timestamp}:t> (<t:{self.timestamp}:R>)"
            embed.add_field(name="Czas rozpoczƒôcia:", value=time_str, inline=False)
            
        if self.participants:
            lines = []
            for uid in self.participants:
                member = guild.get_member(uid)
                if member:
                    lines.append(f"- {member.mention} | **{member.display_name}**")
                else:
                    lines.append(f"- <@{uid}> (U≈ºytkownik opu≈õci≈Ç serwer)")
            embed.add_field(name=f"Zapisani ({len(self.participants)}):", value="\n".join(lines), inline=False)
        else:
            embed.add_field(name="Zapisani:", value="Brak uczestnik√≥w", inline=False)
        embed.set_footer(text=f"Wystawione przez {self.author_name}")
        return embed

    @ui.button(label="‚úÖ Do≈ÇƒÖcz", style=discord.ButtonStyle.green, custom_id="airdrop_join")
    async def join(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer() 
        
        if interaction.user.id in self.participants:
            await interaction.followup.send("Ju≈º jeste≈õ zapisany(a).", ephemeral=True)
            return
        
        if self.message_id not in airdrops:
             await interaction.followup.send("B≈ÇƒÖd: Dane zapisu zaginƒô≈Çy po restarcie bota. Spr√≥buj utworzyƒá nowy zapis.", ephemeral=True)
             return
             
        self.participants.append(interaction.user.id)
        airdrops[self.message_id]["participants"].append(interaction.user.id) 
        
        await interaction.message.edit(embed=self.make_embed(interaction.guild), view=self)
        await interaction.followup.send("‚úÖ Do≈ÇƒÖczy≈Çe≈õ(a≈õ)!", ephemeral=True)

    @ui.button(label="‚ùå Opu≈õƒá", style=discord.ButtonStyle.red, custom_id="airdrop_leave")
    async def leave(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer() 
        
        if interaction.user.id not in self.participants:
            await interaction.followup.send("Nie jeste≈õ zapisany(a).", ephemeral=True)
            return
            
        if self.message_id not in airdrops:
             await interaction.followup.send("B≈ÇƒÖd: Dane zapisu zaginƒô≈Çy po restarcie bota. Spr√≥buj utworzyƒá nowy zapis.", ephemeral=True)
             return
             
        self.participants.remove(interaction.user.id)
        airdrops[self.message_id]["participants"].remove(interaction.user.id)
        await interaction.message.edit(embed=self.make_embed(interaction.guild), view=self)
        await interaction.followup.send("‚ùå Opu≈õci≈Çe≈õ(a≈õ).", ephemeral=True)

class PlayerSelectMenu(ui.Select):
    def __init__(self, capture_id: int, guild: discord.Guild):
        self.capture_id = capture_id
        participant_ids = captures.get(self.capture_id, {}).get("participants", [])
        options = []
        for member_id in participant_ids:
            member = guild.get_member(member_id)
            if member:
                options.append(
                    discord.SelectOption(label=member.display_name, value=str(member.id))
                )

        super().__init__(
            placeholder="Wybierz do 25 graczy",
            max_values=min(25, len(options)),
            options=options,
            custom_id=f"player_select:{capture_id}"
        )

    async def callback(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True) 
        # Zgodnie z logikƒÖ, nie trzeba tu nic robiƒá, poniewa≈º wyb√≥r jest przetwarzany przez przycisk 'Potwierd≈∫ wyb√≥r'
        await interaction.followup.send("Wyb√≥r graczy zosta≈Ç zarejestrowany. Naci≈õnij 'Potwierd≈∫ wyb√≥r'.", ephemeral=True)


class PickPlayersView(ui.View):
    # KRYTYCZNA POPRAWKA: Usuniƒôcie custom_id z super().__init__ (rozwiƒÖzuje TypeError)
    def __init__(self, capture_id: int):
        super().__init__(timeout=180) 
        self.capture_id = capture_id

    @ui.button(label="Potwierd≈∫ wyb√≥r", style=discord.ButtonStyle.green, custom_id="confirm_pick_button")
    async def confirm_pick(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        # Musimy znale≈∫ƒá menu wyboru w interakcji
        select_menu = next((item for item in self.children if item.custom_id == f"player_select:{self.capture_id}"), None)
        
        if not select_menu:
             # Sprawdzamy te≈º, czy menu zosta≈Ço wybrane w interakcji
             select_menu = next((c for c in interaction.message.components[0].children if isinstance(c, ui.Select) and c.custom_id == f"player_select:{self.capture_id}"), None)
             if not select_menu:
                 await interaction.followup.send("B≈ÇƒÖd: Nie znaleziono menu wyboru. Spr√≥buj ponownie.", ephemeral=True)
                 return
             
        # Warto≈õci sƒÖ w obiekcie Select, kt√≥ry jest czƒô≈õciƒÖ interakcji
        # W przypadku widoku tymczasowego, warto≈õci sƒÖ przechowywane w atrybucie `values` elementu `Select`
        # Je≈õli interakcja pochodzi od przycisku, musimy polegaƒá na warto≈õciach zapisanych w state managemencie Discorda.
        
        # POPRAWKA: Musimy uzyskaƒá warto≈õci z interakcji, je≈õli u≈ºytkownik faktycznie co≈õ wybra≈Ç w menu
        # U≈ºyjemy prostej metody sprawdzajƒÖcej, czy w interakcji wystƒôpuje wybrana warto≈õƒá
        
        selected_values = []
        if interaction.data and 'components' in interaction.data and interaction.data['components']:
            for row in interaction.data['components']:
                for component in row.get('components', []):
                    if component.get('custom_id') == f"player_select:{self.capture_id}" and component.get('values'):
                        selected_values = component['values']
                        break
                if selected_values:
                    break

        # Je≈ºeli przycisk "Potwierd≈∫ wyb√≥r" zosta≈Ç naci≈õniƒôty, a u≈ºytkownik nic nie wybra≈Ç w menu Select:
        # Prawid≈Çowe warto≈õci powinny byƒá pobierane z `select_menu.values` (je≈õli interakcja jest typu SELECT_MENU)
        # LUB z danych interakcji, gdy interakcja jest typu BUTTON.
        
        # W tym prostym modelu, polegamy na tym, ≈ºe u≈ºytkownik najpierw wybra≈Ç w Select, a potem kliknƒÖ≈Ç Button.
        # Niestety, Discord nie przekazuje wybranych warto≈õci z Select do callbacka Buttona.
        # Najprostsze rozwiƒÖzanie: u≈ºytkownik wybiera, a nastƒôpnie klika 'Potwierd≈∫ wyb√≥r' W TYM SAMYM WIDOKU.
        
        # Dla uproszczenia, sprawdzamy, czy w danym widoku menu mia≈Ço jakie≈õ wybrane warto≈õci (choƒá to jest niepewne, 
        # bo warto≈õci sƒÖ resetowane po interakcji select)
        
        # PONIEWA≈ª logika ta jest wadliwa w discord.py (przycisk nie widzi wyboru z Selecta), 
        # ZAK≈ÅADAMY, ≈ºe u≈ºytkownik musi najpierw wybraƒá i poczekaƒá na potwierdzenie z PlayerSelectMenu.callback
        # Nastƒôpnie klikniƒôcie przycisku powinno spowodowaƒá odczyt z zapisu sesji (kt√≥rego nie ma w tym kodzie).
        
        # Na razie polegamy na tym, co jest w PlayerSelectMenu.callback (kt√≥re deferuje i nic nie robi).
        # Poprawne dzia≈Çanie wymaga≈Çoby zaawansowanego state managementu lub innego wzorca UI.
        
        # Tymczasowe obej≈õcie (niepewne w 100%): Spr√≥bujemy odczytaƒá z obiektu, kt√≥ry zosta≈Ç dodany do View
        # W tym kodzie to jest trudne. Zmieniamy logikƒô na bezpieczniejszƒÖ:
        
        # Je≈õli nie ma warto≈õci, wysy≈Çamy b≈ÇƒÖd.
        if not select_menu or not select_menu.values:
            await interaction.followup.send("‚ö†Ô∏è Najpierw wybierz graczy z menu rozwijanego (tu≈º nad tym przyciskiem) i poczekaj, a≈º bot zarejestruje wyb√≥r (otrzymaj wiadomo≈õƒá potwierdzajƒÖcƒÖ). Nastƒôpnie naci≈õnij 'Potwierd≈∫ wyb√≥r'.", ephemeral=True)
            return

        selected_values = select_menu.values # Pobieramy warto≈õci z menu Select, je≈õli by≈Çy wybrane w tej interakcji

        if not selected_values:
            await interaction.followup.send("Nie wybrano ≈ºadnych os√≥b! Wybierz je w menu rozwijanym powy≈ºej.", ephemeral=True)
            return

        # Dalsza logika pozostaje bez zmian
        selected_members = [
            interaction.guild.get_member(int(mid))
            for mid in selected_values if interaction.guild.get_member(int(mid))
        ]
        total_participants = len(captures.get(self.capture_id, {}).get("participants", []))
        
        final_embed = discord.Embed(
            title="Lista os√≥b na captures!",
            description=f"Wybrano {len(selected_members)}/{total_participants} os√≥b:",
            color=discord.Color(0xFFFFFF)
        )
        final_embed.add_field(
            name="Wybrani gracze:",
            value="\n".join(f"{i+1}. {m.mention} | **{m.display_name}**" for i, m in enumerate(selected_members)),
            inline=False
        )
        final_embed.set_footer(text=f"Wystawione przez {interaction.user.display_name} ‚Ä¢ {discord.utils.utcnow().strftime('%d.%m.%Y %H:%M')}")
        await interaction.followup.send(embed=final_embed)


class CapturesView(ui.View):
    def __init__(self, capture_id: int, author_name: str, image_url: str = None, timestamp: int = None, started: bool = False): 
        super().__init__(timeout=None)
        self.capture_id = capture_id
        self.author_name = author_name
        self.image_url = image_url
        self.timestamp = timestamp 
        self.custom_id = f"captures_view:{capture_id}"
        self.started = started 
        
    def make_embed(self, guild: discord.Guild):
        participants_ids = captures.get(self.capture_id, {}).get("participants", [])
        
        embed = discord.Embed(title="CAPTURES!", description="Kliknij przycisk, aby siƒô zapisaƒá!", color=discord.Color(0xFFFFFF))
        embed.set_thumbnail(url=LOGO_URL) 
        
        if self.image_url:
            embed.set_image(url=self.image_url)

        if self.timestamp:
            if self.started:
                time_str = "**CAPT rozpoczƒÖ≈Ç siƒô**" 
            else:
                time_str = f"Rozpoczƒôcie CAPT o <t:{self.timestamp}:t> (<t:{self.timestamp}:R>)" 
            
            embed.add_field(name="Czas rozpoczƒôcia:", value=time_str, inline=False)
        
        if participants_ids:
            lines = []
            for uid in participants_ids:
                member = guild.get_member(uid)
                if member:
                    lines.append(f"- {member.mention} | **{member.display_name}**")
                else:
                    lines.append(f"- <@{uid}> (U≈ºytkownik opu≈õci≈Ç serwer)")
            embed.add_field(name=f"Zapisani ({len(participants_ids)}):", value="\n".join(lines), inline=False)
        else:
            embed.add_field(name="Zapisani:", value="Brak uczestnik√≥w", inline=False)
            
        embed.set_footer(text=f"Wystawione przez {self.author_name}")
        return embed

    @ui.button(label="‚úÖ Wpisz siƒô", style=discord.ButtonStyle.green, custom_id="capt_join")
    async def join_button(self, interaction: discord.Interaction, button: ui.Button):
        user_id = interaction.user.id
        participants = captures.get(self.capture_id, {}).get("participants", [])
        
        if user_id not in participants:
            await interaction.response.defer() 
            
            # Weryfikacja istnienia wpisu na wypadek restartu bota
            if self.capture_id not in captures:
                 captures[self.capture_id] = {"participants": [], "author_name": self.author_name, "image_url": self.image_url, "timestamp": self.timestamp, "started": self.started} 
                 
            captures[self.capture_id]["participants"].append(user_id)
            
            data = captures.get(self.capture_id)
            if data and data.get("message"):
                await interaction.message.edit(embed=self.make_embed(interaction.guild), view=self)
                await interaction.followup.send("Zosta≈Çe≈õ(a≈õ) zapisany(a)!", ephemeral=True)
            else:
                await interaction.followup.send("Zosta≈Çe≈õ(a≈õ) zapisany(a), ale wiadomo≈õƒá og≈Çoszenia mog≈Ça zaginƒÖƒá po restarcie bota.", ephemeral=True)
        else:
            await interaction.response.send_message("Ju≈º jeste≈õ zapisany(a).", ephemeral=True)

    @ui.button(label="‚ùå Wypisz siƒô", style=discord.ButtonStyle.red, custom_id="capt_leave")
    async def leave_button(self, interaction: discord.Interaction, button: ui.Button):
        user_id = interaction.user.id
        participants = captures.get(self.capture_id, {}).get("participants", [])
        
        if user_id in participants:
            await interaction.response.defer() 
            
            if self.capture_id not in captures:
                 await interaction.followup.send("B≈ÇƒÖd: Dane zapisu zaginƒô≈Çy po restarcie bota.", ephemeral=True)
                 return
                 
            captures[self.capture_id]["participants"].remove(user_id)
            
            data = captures.get(self.capture_id)
            if data and data.get("message"):
                await interaction.message.edit(embed=self.make_embed(interaction.guild), view=self)
                await interaction.followup.send("Zosta≈Çe≈õ(a≈õ) wypisany(a).", ephemeral=True)
            else:
                 await interaction.followup.send("Zosta≈Çe≈õ(a≈õ) wypisany(a).", ephemeral=True)
        else:
            await interaction.response.send_message("Nie jeste≈õ zapisany(a).", ephemeral=True)

    @ui.button(label="üéØ Pickuj osoby", style=discord.ButtonStyle.blurple, custom_id="capt_pick")
    async def pick_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer(ephemeral=True)
        
        guild_member = interaction.guild.get_member(interaction.user.id)
        # POPRAWKA: Weryfikacja, czy u≈ºytkownik ma rolƒô administracyjnƒÖ LUB pickujƒÖcƒÖ.
        is_admin = interaction.user.id in ADMIN_ROLES
        has_pick_role = PICK_ROLE_ID in [r.id for r in guild_member.roles]
        
        if not (is_admin or has_pick_role):
            await interaction.followup.send("‚õî Brak uprawnie≈Ñ! Wymagana jest rola do pickowania.", ephemeral=True)
            return
            
        participants = captures.get(self.capture_id, {}).get("participants", [])
        if not participants:
            await interaction.followup.send("Nikt siƒô nie zapisa≈Ç!", ephemeral=True)
            return
            
        pick_view = PickPlayersView(self.capture_id)
        # Menu Select musi byƒá dodane DO WIDOKU
        pick_view.add_item(PlayerSelectMenu(self.capture_id, interaction.guild))
        
        await interaction.followup.send("Wybierz do 25 graczy:", view=pick_view, ephemeral=True)


# =======================================================
# <<< FUNKCJE DLA SQUAD√ìW >>>
# =======================================================

def create_squad_embed(guild: discord.Guild, author_name: str, member_ids: list[int], title: str = "Main Squad"):
    """Tworzy embed dla Squadu na podstawie listy ID."""
    
    member_lines = []
    
    for i, uid in enumerate(member_ids):
        member = guild.get_member(uid)
        if member:
            member_lines.append(f"{i+1}- {member.mention} | **{member.display_name}**")
        else:
            member_lines.append(f"{i+1}- <@{uid}> (Nieznany/Opu≈õci≈Ç serwer)")
            
    members_list_str = "\n".join(member_lines) if member_lines else "Brak cz≈Çonk√≥w sk≈Çadu."
    count = len(member_ids)
        
    embed = discord.Embed(
        title=title, 
        description=f"Oto aktualny sk≈Çad:\n\n{members_list_str}", 
        color=discord.Color(0xFFFFFF)
    )
    embed.set_thumbnail(url=LOGO_URL)
    
    embed.add_field(name="Liczba cz≈Çonk√≥w:", value=f"**{count}**", inline=False)
    
    embed.set_footer(text=f"Aktywowane przez {author_name}")
    return embed


class EditSquadView(ui.View):
    # KRYTYCZNA POPRAWKA: Usuniƒôcie custom_id z super().__init__ (rozwiƒÖzuje TypeError)
    def __init__(self, message_id: int):
        super().__init__(timeout=180)
        self.message_id = message_id
        
        self.add_item(ui.UserSelect(
            placeholder="Wybierz cz≈Çonk√≥w sk≈Çadu (max 25)",
            max_values=25, 
            custom_id="squad_member_picker"
        ))

    @ui.button(label="‚úÖ Potwierd≈∫ edycjƒô", style=discord.ButtonStyle.green, custom_id="confirm_edit_squad")
    async def confirm_edit(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer(ephemeral=True)

        select_menu = next((item for item in self.children if item.custom_id == "squad_member_picker"), None)
        selected_ids = []
        if select_menu and select_menu.values:
            selected_ids = [user.id for user in select_menu.values]
        
        squad_data = squads.get(self.message_id)

        if not squad_data:
            await interaction.followup.send("B≈ÇƒÖd: Nie znaleziono danych tego sk≈Çadu. Byƒá mo≈ºe widok wygas≈Ç.", ephemeral=True)
            return

        squad_data["member_ids"] = selected_ids
        
        message = squad_data.get("message")
        author_name = squad_data.get("author_name", "Bot")
        title = "Main Squad"
        if message and message.embeds:
            if message.embeds:
                title = message.embeds[0].title
            
        new_embed = create_squad_embed(interaction.guild, author_name, selected_ids, title)
        
        if message and hasattr(message, 'edit'):
            # Wracamy do widoku permanentnego SquadView
            new_squad_view = SquadView(self.message_id, squad_data.get("role_id"))
            
            role_id = squad_data.get("role_id")
            content = f"<@&{role_id}> **Zaktualizowano Sk≈Çad!**" if role_id else ""
            
            await message.edit(content=content, embed=new_embed, view=new_squad_view)
            
            await interaction.followup.send(content="‚úÖ Sk≈Çad zosta≈Ç pomy≈õlnie zaktualizowany! Wr√≥ƒá do g≈Ç√≥wnej wiadomo≈õci sk≈Çadu.", ephemeral=True)
        else:
            await interaction.followup.send(content="B≈ÇƒÖd: Nie mo≈ºna od≈õwie≈ºyƒá wiadomo≈õci sk≈Çadu. Byƒá mo≈ºe bot zosta≈Ç zrestartowany lub wiadomo≈õƒá usuniƒôta.", ephemeral=True)


class SquadView(ui.View):
    def __init__(self, message_id: int, role_id: int):
        super().__init__(timeout=None)
        self.message_id = message_id
        self.role_id = role_id
        self.custom_id = f"squad_view:{message_id}"

    @ui.button(label="ZarzƒÖdzaj sk≈Çadem (ADMIN)", style=discord.ButtonStyle.blurple, custom_id="manage_squad_button")
    async def manage_squad_button(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer(ephemeral=True) 

        guild_member = interaction.guild.get_member(interaction.user.id)
        # POPRAWKA: Weryfikacja, czy u≈ºytkownik ma rolƒô administracyjnƒÖ.
        if not guild_member or BOT_ADMIN_ROLE_ID not in [r.id for r in guild_member.roles]:
            # Dodatkowa weryfikacja dla u≈ºytkownik√≥w z listy STATUS_ADMINS
            if interaction.user.id not in STATUS_ADMINS:
                await interaction.followup.send("‚õî Brak uprawnie≈Ñ do zarzƒÖdzania sk≈Çadem! Wymagana rola administracyjna.", ephemeral=True)
                return

        squad_data = squads.get(self.message_id)
        if not squad_data:
            await interaction.followup.send("B≈ÇƒÖd: Nie znaleziono danych tego sk≈Çadu.", ephemeral=True)
            return
            
        edit_view = EditSquadView(self.message_id)
            
        await interaction.followup.send(
            "Wybierz listƒô cz≈Çonk√≥w sk≈Çadu (u≈ºyj menu rozwijanego, max 25 os√≥b). Po wybraniu naci≈õnij 'Potwierd≈∫ edycjƒô':", 
            view=edit_view, 
            ephemeral=True
        )

# =======================================================
# <<< KONIEC FUNKCJI DLA SQUAD√ìW >>>
# =======================================================

# =====================
#       FUNKCJONALNO≈öƒÜ TIMERA CAPTURES
# =====================

@tasks.loop(minutes=1.0) 
async def check_captures_end_time():
    """Sprawdza co minutƒô, czy czas rozpoczƒôcia Captures minƒÖ≈Ç."""
    now_utc = discord.utils.utcnow().timestamp()
    
    for msg_id, data in list(captures.items()):
        timestamp = data.get("timestamp")
        started = data.get("started", False)
        message = data.get("message")
        
        if timestamp and not started and now_utc >= timestamp:
            
            captures[msg_id]["started"] = True
            
            if message:
                try:
                    view_obj = CapturesView(
                        msg_id, 
                        data["author_name"], 
                        data.get("image_url"), 
                        timestamp, 
                        started=True
                    )
                    new_embed = view_obj.make_embed(message.guild)
                    
                    await message.edit(embed=new_embed, view=view_obj)
                    print(f"‚úÖ Wiadomo≈õƒá Captures (ID: {msg_id}) zaktualizowana: START.")
                    
                except discord.NotFound:
                    print(f"B≈ÇƒÖd: Nie znaleziono wiadomo≈õci Captures (ID: {msg_id}). Pomijam.")
                    # Nie usuwamy z listy, bo mo≈ºe b≈ÇƒÖd by≈Ç tymczasowy, ale oznaczamy jako "bez wiadomo≈õci"
                    captures[msg_id]["message"] = None 
                    
                except Exception as e:
                    print(f"B≈ÇƒÖd edycji wiadomo≈õci Captures (ID: {msg_id}): {e}")
                    traceback.print_exc()

# =====================
#       KOMENDY
# =====================
@client.event
async def on_ready():
    # Start cyklicznego zadania sprawdzania czasu
    if not check_captures_end_time.is_running():
        check_captures_end_time.start()
        print("‚úÖ Rozpoczƒôto zadanie cykliczne Captures Time Tracker.")

    # Przywracanie widok√≥w (Critical dla persistent views)
    
    # 1. SQUAD VIEWS
    if squads:
        print(f"Pr√≥ba przywr√≥cenia {len(squads)} widok√≥w Squad.")
        for msg_id, data in list(squads.items()):
             try:
                 channel = client.get_channel(data["channel_id"])
                 if channel:
                     # Upewniamy siƒô, ≈ºe wiadomo≈õƒá istnieje i jƒÖ ≈Çapiemy
                     data["message"] = await channel.fetch_message(msg_id)
                     client.add_view(SquadView(msg_id, data["role_id"]))
             except discord.NotFound:
                  print(f"Ostrze≈ºenie: Wiadomo≈õƒá Squad {msg_id} nie zosta≈Ça znaleziona. Usuwam z pamiƒôci.")
                  del squads[msg_id]
             except Exception as e:
                 print(f"B≈ÇƒÖd przy przywracaniu widoku Squad {msg_id}: {e}")
                 
    # 2. CAPTURES VIEWS
    if captures:
        print(f"Pr√≥ba przywr√≥cenia {len(captures)} widok√≥w Captures.")
        for msg_id, data in list(captures.items()):
             try:
                 channel = client.get_channel(data["channel_id"])
                 if channel:
                     data["message"] = await channel.fetch_message(msg_id)
                     image_url = data.get("image_url")
                     timestamp = data.get("timestamp")
                     started = data.get("started", False)
                     client.add_view(CapturesView(msg_id, data["author_name"], image_url, timestamp, started))
             except discord.NotFound:
                  print(f"Ostrze≈ºenie: Wiadomo≈õƒá Captures {msg_id} nie zosta≈Ça znaleziona. Usuwam z pamiƒôci.")
                  del captures[msg_id]
             except Exception as e:
                 print(f"B≈ÇƒÖd przy przywracaniu widoku Captures {msg_id}: {e}")
                 
    # 3. AIRDROP VIEWS
    if airdrops:
        print(f"Pr√≥ba przywr√≥cenia {len(airdrops)} widok√≥w AirDrop.")
        for msg_id, data in list(airdrops.items()):
             try:
                 channel = client.get_channel(data["channel_id"])
                 if channel:
                     data["message"] = await channel.fetch_message(msg_id)
                     voice_channel = client.get_channel(data["voice_channel_id"])
                     
                     if voice_channel:
                         timestamp = data.get("timestamp")
                         view = AirdropView(msg_id, data["description"], voice_channel, data["author_name"], timestamp)
                         view.participants = data.get("participants", []) 
                         client.add_view(view)
                     else:
                         print(f"Ostrze≈ºenie: Nie znaleziono kana≈Çu g≈Çosowego dla AirDrop {msg_id}. Pomijam przywracanie widoku.")
             except discord.NotFound:
                  print(f"Ostrze≈ºenie: Wiadomo≈õƒá AirDrop {msg_id} nie zosta≈Ça znaleziona. Usuwam z pamiƒôci.")
                  del airdrops[msg_id]
             except Exception as e:
                 print(f"B≈ÇƒÖd przy przywracaniu widoku AirDrop {msg_id}: {e}")
                 
    # Synchronizacja komend
    await tree.sync()
    print(f"‚úÖ Zalogowano jako {client.user}")

# Komenda SQUAD
@tree.command(name="create-squad", description="Tworzy og≈Çoszenie o sk≈Çadzie z mo≈ºliwo≈õciƒÖ edycji.")
async def create_squad(interaction: discord.Interaction, rola: discord.Role, tytul: str = "Main Squad"):
    await interaction.response.defer(ephemeral=True) 

    guild_member = interaction.guild.get_member(interaction.user.id)
    if BOT_ADMIN_ROLE_ID not in [r.id for r in guild_member.roles] and interaction.user.id not in STATUS_ADMINS:
        await interaction.followup.send("‚õî Brak uprawnie≈Ñ!", ephemeral=True)
        return

    author_name = interaction.user.display_name
    role_id = rola.id
    
    initial_member_ids = []
    embed = create_squad_embed(interaction.guild, author_name, initial_member_ids, tytul) 
    view = SquadView(0, role_id) 
    
    content = f"{rola.mention}"
    sent = await interaction.channel.send(content=content, embed=embed, view=view)
    
    squads[sent.id] = {
        "role_id": role_id, 
        "member_ids": initial_member_ids, 
        "message": sent, 
        "channel_id": sent.channel.id,
        "author_name": author_name,
    }
    
    view.message_id = sent.id
    view.custom_id = f"squad_view:{sent.id}"
    # Musimy dodaƒá widok do klienta, aby by≈Ç trwa≈Çy (persistent)
    client.add_view(view) 
    # Edycja jest niepotrzebna, view jest ju≈º ustawiony
    
    await interaction.followup.send(f"‚úÖ Og≈Çoszenie o sk≈Çadzie '{tytul}' dla roli {rola.mention} wys≈Çane!", ephemeral=True)


# Komenda CAPTURES (Z TIMMEREM)
@tree.command(name="create-capt", description="Tworzy og≈Çoszenie o captures z opcjonalnym timerem i zdjƒôciem.")
async def create_capt(interaction: discord.Interaction, czas_zakonczenia: str, data_zakonczenia: str = None, link_do_zdjecia: str = None):
    await interaction.response.defer(ephemeral=True) 
    
    # Dodatkowa weryfikacja uprawnie≈Ñ (chocia≈º komenda jest publiczna, dla bezpiecze≈Ñstwa):
    guild_member = interaction.guild.get_member(interaction.user.id)
    if BOT_ADMIN_ROLE_ID not in [r.id for r in guild_member.roles] and interaction.user.id not in STATUS_ADMINS:
        # Mo≈ºesz usunƒÖƒá tƒô weryfikacjƒô, je≈õli komenda ma byƒá dostƒôpna dla wszystkich.
        pass # W tym przypadku zostawiamy, ≈ºe mo≈ºe jƒÖ u≈ºyƒá ka≈ºdy.
    
    try:
        timestamp = create_timestamp(czas_zakonczenia, data_zakonczenia)
    except ValueError as e:
        await interaction.followup.send(f"‚ùå B≈ÇƒÖd formatu czasu/daty: **{e}**", ephemeral=True)
        return
    
    started = discord.utils.utcnow().timestamp() >= timestamp
    
    author_name = interaction.user.display_name
    
    view = CapturesView(0, author_name, link_do_zdjecia, timestamp, started) 
    embed = view.make_embed(interaction.guild)
    
    sent = await interaction.channel.send(content="@everyone", embed=embed, view=view)
    
    captures[sent.id] = {
        "participants": [], 
        "message": sent, 
        "channel_id": sent.channel.id, 
        "author_name": author_name,
        "image_url": link_do_zdjecia, 
        "timestamp": timestamp,
        "started": started 
    }
    
    view.capture_id = sent.id 
    view.custom_id = f"captures_view:{sent.id}"
    client.add_view(view) # Dodajemy widok do klienta
    # Edycja niepotrzebna
    
    await interaction.followup.send("Og≈Çoszenie o captures wys≈Çane!", ephemeral=True)

# Komenda AirDrop (Z TIMMEREM)
@tree.command(name="airdrop", description="Tworzy og≈Çoszenie o AirDropie z timerem.")
async def airdrop_command(interaction: discord.Interaction, channel: discord.TextChannel, voice: discord.VoiceChannel, role: discord.Role, opis: str, czas_zakonczenia: str, data_zakonczenia: str = None):
    await interaction.response.defer(ephemeral=True) 
    
    guild_member = interaction.guild.get_member(interaction.user.id)
    if BOT_ADMIN_ROLE_ID not in [r.id for r in guild_member.roles] and interaction.user.id not in STATUS_ADMINS:
        await interaction.followup.send("‚õî Brak uprawnie≈Ñ!", ephemeral=True)
        return
    
    try:
        timestamp = create_timestamp(czas_zakonczenia, data_zakonczenia)
    except ValueError as e:
        await interaction.followup.send(f"‚ùå B≈ÇƒÖd formatu czasu/daty: **{e}**", ephemeral=True)
        return
        
    view = AirdropView(0, opis, voice, interaction.user.display_name, timestamp) 
    embed = view.make_embed(interaction.guild)
    sent = await channel.send(content=f"{role.mention}", embed=embed, view=view)
    
    airdrops[sent.id] = {
        "participants": [], 
        "message": sent, 
        "channel_id": sent.channel.id, 
        "description": opis, 
        "voice_channel_id": voice.id, 
        "author_name": interaction.user.display_name,
        "timestamp": timestamp 
    }
    
    view.message_id = sent.id
    view.custom_id = f"airdrop_view:{sent.id}"
    client.add_view(view) # Dodajemy widok do klienta
    
    await interaction.followup.send("‚úÖ AirDrop utworzony!", ephemeral=True)

# Eventy Zancudo / Cayo
@tree.command(name="ping-zancudo", description="Wysy≈Ça og≈Çoszenie o ataku na Fort Zancudo.")
async def ping_zancudo(interaction: discord.Interaction, role: discord.Role, channel: discord.VoiceChannel):
    await interaction.response.defer(ephemeral=True) 

    guild_member = interaction.guild.get_member(interaction.user.id)
    if BOT_ADMIN_ROLE_ID not in [r.id for r in guild_member.roles] and interaction.user.id not in STATUS_ADMINS:
        await interaction.followup.send("‚õî Brak uprawnie≈Ñ!", ephemeral=True)
        return

    embed = discord.Embed(title="Atak na FORT ZANCUDO!", description=f"Zapraszamy na {channel.mention}!", color=discord.Color(0xFF0000))
    embed.set_image(url=ZANCUDO_IMAGE_URL)
    embed.set_thumbnail(url=LOGO_URL) 
    sent = await interaction.channel.send(content=f"{role.mention}", embed=embed)
    events["zancudo"][sent.id] = {"participants": [], "message": sent, "channel_id": sent.channel.id}
    await interaction.followup.send("‚úÖ Og≈Çoszenie o ataku wys≈Çane!", ephemeral=True)

@tree.command(name="ping-cayo", description="Wysy≈Ça og≈Çoszenie o ataku na Cayo Perico.")
async def ping_cayo(interaction: discord.Interaction, role: discord.Role, channel: discord.VoiceChannel):
    await interaction.response.defer(ephemeral=True) 

    guild_member = interaction.guild.get_member(interaction.user.id)
    if BOT_ADMIN_ROLE_ID not in [r.id for r in guild_member.roles] and interaction.user.id not in STATUS_ADMINS:
        await interaction.followup.send("‚õî Brak uprawnie≈Ñ!", ephemeral=True)
        return

    embed = discord.Embed(title="Atak na CAYO PERICO!", description=f"Zapraszamy na {channel.mention}!", color=discord.Color(0xFFAA00))
    embed.set_image(url=CAYO_IMAGE_URL)
    embed.set_thumbnail(url=LOGO_URL) 
    sent = await interaction.channel.send(content=f"{role.mention}", embed=embed)
    events["cayo"][sent.id] = {"participants": [], "message": sent, "channel_id": sent.channel.id}
    await interaction.followup.send("‚úÖ Og≈Çoszenie o ataku wys≈Çane!", ephemeral=True)

# Lista wszystkich zapisanych
@tree.command(name="list-all", description="Pokazuje listƒô wszystkich zapisanych")
async def list_all(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True) 
    
    guild_member = interaction.guild.get_member(interaction.user.id)
    if BOT_ADMIN_ROLE_ID not in [r.id for r in guild_member.roles] and interaction.user.id not in STATUS_ADMINS:
        await interaction.followup.send("‚õî Brak uprawnie≈Ñ do u≈ºycia tej komendy!", ephemeral=True)
        return
        
    desc = ""
    for name, mid, data in get_all_active_enrollments():
        desc += f"\n**{name} (msg {mid})**: {len(data['participants'])} os√≥b"
        
    for mid, data in squads.items():
        count = len(data.get('member_ids', []))
        title = data.get('message').embeds[0].title if data.get('message') and data.get('message').embeds else "Squad"
        desc += f"\n**{title} (msg {mid})**: {count} os√≥b"

    if not desc:
        desc = "Brak aktywnych zapis√≥w i sk≈Çad√≥w."
    embed = discord.Embed(title="üìã Lista wszystkich zapisanych i sk≈Çad√≥w", description=desc, color=discord.Color(0xFFFFFF))
    await interaction.followup.send(embed=embed, ephemeral=True)

# Set status
@tree.command(name="set-status", description="Zmienia status i aktywno≈õƒá bota (tylko admini)")
async def set_status(interaction: discord.Interaction, status: str, opis_aktywnosci: str = None, typ_aktywnosci: str = None, url_stream: str = None):
    await interaction.response.defer(ephemeral=True, thinking=True) 

    if interaction.user.id not in STATUS_ADMINS:
        await interaction.followup.send("‚õî Brak uprawnie≈Ñ!", ephemeral=True)
        return

    status_map = {
        "online": discord.Status.online,
        "idle": discord.Status.idle,
        "dnd": discord.Status.dnd,
        "invisible": discord.Status.invisible,
    }
    
    activity_type_map = {
        "gra": discord.ActivityType.playing,    
        "slucha": discord.ActivityType.listening, 
        "patrzy": discord.ActivityType.watching,   
        "stream": discord.ActivityType.streaming,  
    }

    if status.lower() not in status_map:
        await interaction.followup.send("‚ö†Ô∏è Nieprawid≈Çowy status. U≈ºyj: online/idle/dnd/invisible.", ephemeral=True)
        return
        
    activity = None
    if opis_aktywnosci:
        activity_type = discord.ActivityType.playing 
        
        if typ_aktywnosci and typ_aktywnosci.lower() in activity_type_map:
            activity_type = activity_type_map[typ_aktywnosci.lower()]

        if activity_type == discord.ActivityType.streaming:
            if not url_stream or not (url_stream.startswith('http://') or url_stream.startswith('https://')):
                await interaction.followup.send("‚ö†Ô∏è Aby ustawiƒá 'stream', musisz podaƒá poprawny link (URL) do streamu w argumencie `url_stream`!", ephemeral=True)
                return
            
            activity = discord.Activity(
                name=opis_aktywnosci,
                type=discord.ActivityType.streaming,
                url=url_stream
            )
        else:
            activity = discord.Activity(
                name=opis_aktywnosci,
                type=activity_type
            )

    await client.change_presence(status=status_map[status.lower()], activity=activity)
    
    response_msg = f"‚úÖ Status ustawiony na **{status.upper()}**"
    if opis_aktywnosci:
        if activity_type == discord.ActivityType.playing:
            activity_text = f"Gra w **{opis_aktywnosci}**"
        elif activity_type == discord.ActivityType.listening:
            activity_text = f"S≈Çucha **{opis_aktywnosci}**"
        elif activity_type == discord.ActivityType.watching:
            activity_text = f"OglƒÖda **{opis_aktywnosci}**"
        elif activity_type == discord.ActivityType.streaming:
            activity_text = f"Streamuje **{opis_aktywnosci}** (URL: {url_stream})"
        else:
             activity_text = f"Aktywno≈õƒá: **{opis_aktywnosci}**"
             
        response_msg += f" z aktywno≈õciƒÖ: **{activity_text}**"

    await interaction.followup.send(response_msg, ephemeral=True)

# Wypisz z capt
class RemoveEnrollmentView(ui.View):
    def __init__(self, member_to_remove: discord.Member):
        super().__init__(timeout=180)
        self.member_to_remove = member_to_remove
        self.custom_id = f"remove_enrollment_view:{member_to_remove.id}"
        self.add_item(EnrollmentSelectMenu("remove"))

    @ui.button(label="Potwierd≈∫ usuniƒôcie", style=discord.ButtonStyle.red, custom_id="confirm_remove_button")
    async def confirm_remove(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer() 
        
        select_menu = next((item for item in self.children if isinstance(item, ui.Select)), None)
        if not select_menu or not select_menu.values:
            await interaction.followup.send("‚ö†Ô∏è Najpierw wybierz zapis z listy!", ephemeral=True)
            return

        type_str, msg_id_str = select_menu.values[0].split('-')
        msg_id = int(msg_id_str)
        user_id = self.member_to_remove.id
        
        data_dict = None
        if type_str == "captures":
            data_dict = captures.get(msg_id)
        elif type_str == "airdrop":
            data_dict = airdrops.get(msg_id)
        elif type_str in events:
            data_dict = events[type_str].get(msg_id)

        if not data_dict:
            await interaction.followup.edit_message(
                interaction.message.id,
                content="‚ùå B≈ÇƒÖd: Nie znaleziono aktywnego zapisu o tym ID.",
                view=None
            )
            return

        participants = data_dict.get("participants", [])
        
        if user_id not in participants:
            await interaction.followup.edit_message(
                interaction.message.id,
                content=f"‚ö†Ô∏è **{self.member_to_remove.display_name}** nie jest zapisany(a) na ten **{type_str.capitalize()}**.",
                view=None
            )
            return

        participants.remove(user_id)
        
        message = data_dict.get("message")
        if message and hasattr(message, 'edit'):
            if type_str == "airdrop":
                voice_channel = message.guild.get_channel(data_dict["voice_channel_id"])
                description = data_dict["description"]
                author_name = data_dict["author_name"]
                timestamp = data_dict.get("timestamp")
                
                view_obj = AirdropView(msg_id, description, voice_channel, author_name, timestamp) 
                view_obj.participants = participants
                airdrops[msg_id]["participants"] = participants
                await message.edit(embed=view_obj.make_embed(message.guild), view=view_obj)
            elif type_str == "captures":
                 captures[msg_id]["participants"] = participants
                 author_name = data_dict["author_name"]
                 image_url = data_dict.get("image_url") 
                 timestamp = data_dict.get("timestamp")
                 started = data_dict.get("started", False)
                 view_obj = CapturesView(msg_id, author_name, image_url, timestamp, started) 
                 new_embed = view_obj.make_embed(message.guild)
                 await message.edit(embed=new_embed, view=view_obj)
            elif type_str in events:
                 events[type_str][msg_id]["participants"] = participants

        await interaction.followup.edit_message(
            interaction.message.id,
            content=f"‚úÖ Pomy≈õlnie wypisano **{self.member_to_remove.display_name}** z **{type_str.capitalize()}** (ID: `{msg_id}`).",
            view=None
        )

# Wpisz na capt
class AddEnrollmentView(ui.View):
    def __init__(self, member_to_add: discord.Member):
        super().__init__(timeout=180)
        self.member_to_add = member_to_add
        self.custom_id = f"add_enrollment_view:{member_to_add.id}"
        self.add_item(EnrollmentSelectMenu("add"))

    @ui.button(label="Potwierd≈∫ dodanie", style=discord.ButtonStyle.green, custom_id="confirm_add_button")
    async def confirm_add(self, interaction: discord.Interaction, button: ui.Button):
        await interaction.response.defer() 
        
        select_menu = next((item for item in self.children if isinstance(item, ui.Select)), None)
        if not select_menu or not select_menu.values:
            await interaction.followup.send("‚ö†Ô∏è Najpierw wybierz zapis z listy!", ephemeral=True)
            return

        type_str, msg_id_str = select_menu.values[0].split('-')
        msg_id = int(msg_id_str)
        user_id = self.member_to_add.id
        
        data_dict = None
        if type_str == "captures":
            data_dict = captures.get(msg_id)
        elif type_str == "airdrop":
            data_dict = airdrops.get(msg_id)
        elif type_str in events:
            data_dict = events[type_str].get(msg_id)

        if not data_dict:
            await interaction.followup.edit_message(
                interaction.message.id,
                content="‚ùå B≈ÇƒÖd: Nie znaleziono aktywnego zapisu o tym ID.",
                view=None
            )
            return

        participants = data_dict.get("participants", [])
        
        if user_id in participants:
            await interaction.followup.edit_message(
                interaction.message.id,
                content=f"‚ö†Ô∏è **{self.member_to_add.display_name}** jest ju≈º zapisany(a) na ten **{type_str.capitalize()}**.",
                view=None
            )
            return

        participants.append(user_id)
        
        message = data_dict.get("message")
        if message and hasattr(message, 'edit'):
             if type_str == "airdrop":
                voice_channel = message.guild.get_channel(data_dict["voice_channel_id"])
                description = data_dict["description"]
                author_name = data_dict["author_name"]
                timestamp = data_dict.get("timestamp")

                view_obj = AirdropView(msg_id, description, voice_channel, author_name, timestamp) 
                view_obj.participants = participants
                airdrops[msg_id]["participants"] = participants
                await message.edit(embed=view_obj.make_embed(message.guild), view=view_obj)
             elif type_str == "captures":
                 captures[msg_id]["participants"] = participants
                 author_name = data_dict["author_name"]
                 image_url = data_dict.get("image_url") 
                 timestamp = data_dict.get("timestamp")
                 started = data_dict.get("started", False)
                 view_obj = CapturesView(msg_id, author_name, image_url, timestamp, started) 
                 new_embed = view_obj.make_embed(message.guild)
                 await message.edit(embed=new_embed, view=view_obj)
             elif type_str in events:
                 events[type_str][msg_id]["participants"] = participants

        await interaction.followup.edit_message(
            interaction.message.id,
            content=f"‚úÖ Pomy≈õlnie wpisano **{self.member_to_add.display_name}** na **{type_str.capitalize()}** (ID: `{msg_id}`).",
            view=None
        )

@tree.command(name="wpisz-na-capt", description="Wpisuje u≈ºytkownika na dowolny aktywny zapis (Captures, AirDrop, Event).")
async def add_to_enrollment(interaction: discord.Interaction, cz≈Çonek: discord.Member):
    await interaction.response.defer(ephemeral=True) 
    
    guild_member = interaction.guild.get_member(interaction.user.id)
    if BOT_ADMIN_ROLE_ID not in [r.id for r in guild_member.roles] and interaction.user.id not in STATUS_ADMINS:
        await interaction.followup.send("‚õî Brak uprawnie≈Ñ do u≈ºycia tej komendy!", ephemeral=True)
        return
        
    enrollments = get_all_active_enrollments()
    if not enrollments:
        await interaction.followup.send("‚ö†Ô∏è Brak aktywnych zapis√≥w, na kt√≥re mo≈ºna wpisaƒá u≈ºytkownika.", ephemeral=True)
        return
        
    await interaction.followup.send(
        f"Wybierz zapis, na kt√≥ry wpisaƒá **{cz≈Çonek.display_name}**:", 
        view=AddEnrollmentView(cz≈Çonek), 
        ephemeral=True
    )


# --- Start bota ---
def run_discord_bot():
    try:
        # U≈ºywamy wszystkich intents√≥w
        client.run(token)
    except Exception as e:
        print(f"B≈ÇƒÖd uruchomienia bota: {e}")

# Uruchomienie Flask w osobnym wƒÖtku
threading.Thread(target=run_discord_bot).start()

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 10000))
    # U≈ºywamy `app.run` z parametrem `host="0.0.0.0"` dla Render
    app.run(host="0.0.0.0", port=port, debug=False)
